<template>
  <div class="panel">
    <div class="panel-header">
      <el-row  type="flex" align="middle">
        <div style="width: 32px;height: 32px;margin-right: 10px;position: relative;">
          <img src="~@/assets/logo.png" alt="梦幻灵瞳"
          style="width: 32px;height: 32px;">
          <span class="status-dot"
          :class="{ 'connected': devtoolsConnected, 'disconnected': !devtoolsConnected }"></span>
        </div> 
      <h3 style="color: #fff;">梦幻灵瞳</h3>
      </el-row>
      <div class="connection-status">
        <div class="pages"><a href="javascript:goto(1)" @click="prevPage">上一页</a><a href="javascript:goto(1)" @click="nextPage">下一页</a></div>
        <el-button @click="getPageInfo" size="mini" type="info">页码信息</el-button>
        <el-button @click="reconnectDevTools" size="mini" type="warning" v-if="!devtoolsConnected">重连</el-button>
        <a  v-if="!isInNewWindow" href="javascript:;" class=" btn1 js_alert_btn_0" @click="openInNewTab">新窗口打开</a>
        <a href="javascript:;" class=" btn1 js_alert_btn_0" @click="clearData">清空数据</a>
      </div>
    </div>
    <div class="data-section">
      <el-empty v-if="recommendData.length === 0" class="empty-state" description="暂无数据，请访问梦幻西游藏宝阁页面"></el-empty>
      <div v-else class="request-list">
        <div v-for="item in recommendData" :key="item.requestId" class="request-item"
          :class="{ 'completed': item.status === 'completed' }">
          <div class="request-info">
            <div class="request-meta">
              <span class="status" :class="item.status">{{ item.status === 'completed' ? '解析完成' : '解析中' }}</span>
              <span class="timestamp">{{ formatTime(item.timestamp) }}</span>
            </div>
          </div>
          <div v-if="item.responseData" class="response-data">
            <el-row :gutter="4">
              <el-col v-for="role in parseListData(item.responseData)?.equip_list" :key="role.eid"
                style="width: 20%;margin-bottom: 2px;margin-top: 2px;">
                <el-card class="role-card" :class="{ 'empty-role': isEmptyRole(parserRoleData(role)) }">
                  <el-row type="flex" justify="space-between">
                    <el-col style="width:50px;flex-shrink: 0;margin-right: 4px;">
                <RoleImage :key="role.eid" :other_info="role.other_info" :roleInfo="parserRoleData(role)" />
                      <el-link :href="getCBGLinkByType(role.eid, 'role')" type="danger" target="_blank"
                        style="white-space: nowrap;text-overflow: ellipsis;overflow: hidden;display: block;font-size: 12px;">
                        {{ role.seller_nickname }}</el-link>
                    </el-col>
                    <el-col>
                      <div>
                        <el-tag type="success" v-if="role.accept_bargain == 1">接受还价</el-tag>
                        <el-tag type="danger" v-else>拒绝还价</el-tag>
                      </div>
                      <div>
                        <span v-html="formatFullPrice(role.price, true)"></span>
                      </div>
                      <div>
                        <el-tag type="danger" v-if="isEmptyRole(parserRoleData(role))">空号</el-tag>
                        <template v-else>
                          <el-tag>⚔️{{ get_equip_num(parserRoleData(role)) }}</el-tag>
                          <el-tag>🐲{{ get_pet_num(parserRoleData(role)) }}</el-tag>
                        </template>
                      </div>
                    </el-col>
                  </el-row>
                </el-card>
              </el-col>
            </el-row>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
<script>
import RoleImage from '@/components/RoleInfo/RoleImage.vue'
import { commonMixin } from '@/utils/mixins/commonMixin'
export default {
  name: 'DevToolsPanel',
  data() {
    return {
      recommendData: [],
      expandedItems: [],
      processedRequests: new Set(), // 记录已处理的请求ID
      devtoolsConnected: false, // DevTools Protocol连接状态
      connectionStatus: '检查中...', // 连接状态描述
      connectionCheckTimer: null, // 连接检查定时器
      isInNewWindow: false // 是否在新窗口中打开
    }
  },
  mixins: [commonMixin],
  components: {
    RoleImage
  },
  computed: {

  },
  mounted() {
    this.initMessageListener()
    this.checkConnectionStatus()
    this.checkIfInNewWindow()

    // // 设置定时检查（每5秒检查一次）
    // this.connectionCheckTimer = setInterval(() => {
    //   this.checkConnectionStatus()
    // }, 5000)
  },
  beforeDestroy() {
    // 移除Chrome消息监听器
    this.removeMessageListener()
    // 清理定时器
    if (this.connectionCheckTimer) {
      clearInterval(this.connectionCheckTimer)
      this.connectionCheckTimer = null
    }
    // 清理组件状态
    this.recommendData = []
    this.expandedItems = []
  },
  methods: {
    isEmptyRole(roleInfo) {
      const noEquip = this.get_equip_num(roleInfo) === 0
      let noPet = true
      for (let pet of roleInfo.pet_info) {
        if (pet.pet_grade > 100 && pet.is_baobao === '是') {
          noPet = false
          break
        }
        if (pet.pet_grade > 100 && pet.is_baobao === '否' && pet.all_skills.length > 4) {
          noPet = false
          break
        }
      }
      return noEquip && noPet
    },
    get_pet_num(roleInfo) {
      return roleInfo.pet_info.length + roleInfo.split_pets.length
    },
    get_equip_num(roleInfo) {
      return roleInfo.using_equips.length + roleInfo.not_using_equips.length + roleInfo.split_equips.length
    },
    nextPage() {
      // 通过Chrome调试API查找并点击页面上的分页器
      this.clickPageButton('next')
    },

    prevPage() {
      // 通过Chrome调试API查找并点击页面上的分页器
      this.clickPageButton('prev')
    },

    getPageInfo() {
      // 获取当前分页器信息
      this.getPagerInfo()
    },

    reconnectDevTools() {
      // 重新连接DevTools
      this.connectionStatus = '重连中...'
      this.checkConnectionStatus()
      this.$notify.info('正在尝试重新连接DevTools...')
    },

    async clickPageButton(direction) {
      try {
        // 获取当前活动标签页
        const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true })

        if (!activeTab || !activeTab.url.includes('cbg.163.com')) {
          this.$notify.warning('请先访问梦幻西游藏宝阁页面')
          return
        }

        // 检查Chrome调试API连接状态
        if (!this.devtoolsConnected) {
          this.$notify.warning('DevTools连接已断开，请重新加载页面')
          return
        }

        // 通过Chrome调试API执行页面JavaScript代码
        const result = await chrome.debugger.sendCommand(
          { tabId: activeTab.id },
          'Runtime.evaluate',
          {
            expression: `
              (function() {
                try {
                  // 查找id为pager的div
                  const pagerDiv = document.getElementById('pager')
                  if (!pagerDiv) {
                    return 'ERROR:未找到分页器元素'
                  }
                  
                  let targetButton = null
                  const isNext = '${direction}' === 'next'
                  
                  if (isNext) {
                    // 查找下一页按钮 - 根据实际HTML格式优化
                    // 1. 优先查找包含"下一页"文本的链接
                    const allLinks = pagerDiv.querySelectorAll('a')
                    for (let link of allLinks) {
                      const text = link.textContent.trim()
                      if (text === '下一页') {
                        targetButton = link
                        break
                      }
                    }
                    
                    // 2. 如果没找到"下一页"，查找包含goto函数的链接（排除当前页）
                    if (!targetButton) {
                      for (let link of allLinks) {
                        const href = link.getAttribute('href')
                        const text = link.textContent.trim()
                        // 查找包含goto且不是当前页的链接
                        if (href && href.includes('goto(') && !link.classList.contains('on')) {
                          // 获取当前页码
                          const currentPageLink = pagerDiv.querySelector('a.on')
                          if (currentPageLink) {
                            const currentPageText = currentPageLink.textContent.trim()
                            const currentPage = parseInt(currentPageText)
                            const linkPage = parseInt(text)
                            // 如果链接页码大于当前页码，说明是下一页
                            if (!isNaN(linkPage) && linkPage > currentPage) {
                              targetButton = link
                              break
                            }
                          }
                        }
                      }
                    }
                  } else {
                    // 查找上一页按钮
                    const allLinks = pagerDiv.querySelectorAll('a')
                    
                    // 1. 优先查找包含"上一页"文本的链接
                    for (let link of allLinks) {
                      const text = link.textContent.trim()
                      if (text === '上一页') {
                        targetButton = link
                        break
                      }
                    }
                    
                    // 2. 如果没找到"上一页"，查找包含goto函数的链接（排除当前页）
                    if (!targetButton) {
                      for (let link of allLinks) {
                        const href = link.getAttribute('href')
                        const text = link.textContent.trim()
                        // 查找包含goto且不是当前页的链接
                        if (href && href.includes('goto(') && !link.classList.contains('on')) {
                          // 获取当前页码
                          const currentPageLink = pagerDiv.querySelector('a.on')
                          if (currentPageLink) {
                            const currentPageText = currentPageLink.textContent.trim()
                            const currentPage = parseInt(currentPageText)
                            const linkPage = parseInt(text)
                            // 如果链接页码小于当前页码，说明是上一页
                            if (!isNaN(linkPage) && linkPage < currentPage) {
                              targetButton = link
                              break
                            }
                          }
                        }
                      }
                    }
                  }
                  
                  if (!targetButton) {
                    return 'ERROR:未找到${direction === 'next' ? '下一页' : '上一页'}按钮'
                  }
                  
                  // 检查按钮是否可点击
                  if (targetButton.disabled || targetButton.classList.contains('disabled')) {
                    return 'ERROR:${direction === 'next' ? '下一页' : '上一页'}按钮不可点击，可能已到${direction === 'next' ? '最后一页' : '第一页'}'
                  }
                  
                  // 获取当前页码信息用于日志
                  const currentPageLink = pagerDiv.querySelector('a.on')
                  let currentPageInfo = ''
                  if (currentPageLink) {
                    const currentPageText = currentPageLink.textContent.trim()
                    currentPageInfo = ' (当前第' + currentPageText + '页)'
                  }
                  
                  // 点击按钮
                  targetButton.click()
                  return 'SUCCESS:已点击${direction === 'next' ? '下一页' : '上一页'}按钮' + currentPageInfo
                } catch (error) {
                  return 'ERROR:执行失败 - ' + error.message
                }
              })()
            `
          }
        )

        // 处理Chrome调试API的返回结果
        if (result && result.result && result.result.value) {
          const message = result.result.value

          if (message.startsWith('SUCCESS:')) {
            this.$notify.success(message.substring(8)) // 移除"SUCCESS:"前缀
            console.log(`${direction === 'next' ? '下一页' : '上一页'}按钮点击成功`)
          } else if (message.startsWith('ERROR:')) {
            this.$notify.warning(message.substring(6)) // 移除"ERROR:"前缀
            console.warn(`${direction === 'next' ? '下一页' : '上一页'}按钮点击失败:`, message)
          } else {
            this.$notify.error('执行页面操作失败：未知返回结果')
            console.error('页面操作结果异常:', result)
          }
        } else {
          this.$notify.error('执行页面操作失败')
          console.error('页面操作结果异常:', result)
        }

      } catch (error) {
        console.error(`点击${direction === 'next' ? '下一页' : '上一页'}按钮失败:`, error)

        // 检查是否是连接断开错误
        if (error.message && error.message.includes('Could not establish connection')) {
          this.devtoolsConnected = false
          this.connectionStatus = '连接断开'
          this.$notify.error('DevTools连接已断开，请重新加载页面或刷新扩展')
        } else {
          this.$notify.error('操作失败: ' + error.message)
        }
      }
    },

    async getPagerInfo() {
      try {
        // 获取当前活动标签页
        const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true })

        if (!activeTab || !activeTab.url.includes('cbg.163.com')) {
          this.$notify.warning('请先访问梦幻西游藏宝阁页面')
          return
        }

        // 检查Chrome调试API连接状态
        if (!this.devtoolsConnected) {
          this.$notify.warning('DevTools连接已断开，请重新加载页面')
          return
        }

        // 通过Chrome调试API执行页面JavaScript代码获取分页器信息
        //在pagerDiv的innerText中查找 `共100页`，获取100
        const result = await chrome.debugger.sendCommand(
          { tabId: activeTab.id },
          'Runtime.evaluate',
          {
            expression: `
              (function() {
                try {
                  // 查找id为pager的div
                  const pagerDiv = document.getElementById('pager')
                  if (!pagerDiv) {
                    return 'ERROR:未找到分页器元素'
                  }
                  
                  // 获取当前页码
                  const currentPageLink = pagerDiv.querySelector('a.on')
                  let currentPage = '未知'
                  if (currentPageLink) {
                    currentPage = currentPageLink.textContent.trim()
                  }
                  
                  // 从innerText中查找"共X页"模式
                  let totalPages = '未知'
                  const innerText = pagerDiv.innerText || pagerDiv.textContent || ''
                  
                  // 手动查找"共"和"页"之间的数字
                  const gongIndex = innerText.indexOf('共')
                  const yeIndex = innerText.indexOf('页', gongIndex)
                  
                  if (gongIndex !== -1 && yeIndex !== -1) {
                    const textBetween = innerText.substring(gongIndex + 1, yeIndex).trim()
                    totalPages = textBetween
                    console.log('textBetween:', textBetween)
                    const numberMatch = textBetween.match(/(\d+)/)
                    if (numberMatch) {
                      totalPages = numberMatch[1]
                    }
                  }
                  
                  // 检查是否有上一页/下一页按钮
                  const hasPrev = pagerDiv.querySelector('a[href*="goto("]') && 
                                 pagerDiv.textContent.includes('上一页')
                  const hasNext = pagerDiv.querySelector('a[href*="goto("]') && 
                                 pagerDiv.textContent.includes('下一页')
                  
                  return 'SUCCESS:第' + currentPage + '页，共' + totalPages + '页 (上一页:' + (hasPrev ? '有' : '无') + ', 下一页:' + (hasNext ? '有' : '无') + ')'
                } catch (error) {
                  return 'ERROR:获取分页器信息失败 - ' + error.message
                }
              })()
            `
          }
        )

        // 处理返回结果
        if (result && result.result && result.result.value) {
          const message = result.result.value

          if (message.startsWith('SUCCESS:')) {
            this.$notify.info(message.substring(8)) // 移除"SUCCESS:"前缀
            console.log('分页器信息获取成功:', message)
          } else if (message.startsWith('ERROR:')) {
            this.$notify.warning(message.substring(6)) // 移除"ERROR:"前缀
            console.warn('分页器信息获取失败:', message)
          } else {
            this.$notify.error('获取分页器信息失败：未知返回结果')
            console.error('分页器信息获取结果异常:', result)
          }
        } else {
          this.$notify.error('获取分页器信息失败')
          console.error('分页器信息获取结果异常:', result)
        }

      } catch (error) {
        console.error('获取分页器信息失败:', error)

        // 检查是否是连接断开错误
        if (error.message && error.message.includes('Could not establish connection')) {
          this.devtoolsConnected = false
          this.connectionStatus = '连接断开'
          this.$notify.error('DevTools连接已断开，请重新加载页面或刷新扩展')
        } else {
          this.$notify.error('操作失败: ' + error.message)
        }
      }
    },
    parserRoleData(data) {
      const roleInfo = new window.RoleInfoParser(data.large_equip_desc, { equip_level: data.equip_level })
      console.log('roleInfo:', roleInfo)
      return roleInfo.result
      // return {
      //   RoleInfoParser: roleInfo,
      //   roleInfo: roleInfo.result,
      //   accept_bargain: data.accept_bargain,
      //   collect_num: data.collect_num,
      //   dynamic_tags: data.dynamic_tags,
      //   eid: data.eid,
      //   highlight: data.highlight,
      //   is_split_independent_role: data.is_split_independent_role,
      //   is_split_main_role: data.is_split_main_role,
      //   large_equip_desc: data.large_equip_desc,
      //   level: data.level,
      //   other_info: data.other_info,
      //   school: data.school,
      //   seller_nickname: data.seller_nickname,
      //   server_name: data.server_name,
      //   serverid: data.serverid,
      //   price: data.price,
      //   sum_exp: data.sum_exp,
      //   create_time: data.create_time,
      //   update_time: data.create_time,
      //   all_equip_json: '',
      //   all_summon_json: '',
      //   split_price_desc: '',
      //   pet_price: '',
      //   equip_price: '',
      //   base_price: '',
      //   history_price: '',
      // }
    },
    parseListData(responseDataStr) {
      // 解析响应数据 Request.JSONP.request_map.request_数字(xxxx) 中的xxxx
      const match = responseDataStr.match(/Request\.JSONP\.request_map\.request_\d+\((.*)\)/)
      let templateJSONStr = '{}'
      if (match) {
        templateJSONStr = match[1]
      } else {
        templateJSONStr = responseDataStr
      }
      try {
        let templateJSON = {}
        if (typeof templateJSONStr === 'string') {
          templateJSON = JSON.parse(templateJSONStr)
        } else {
          // h5
          templateJSON = templateJSONStr
        }
        return templateJSON
      } catch (error) {
        console.error('解析响应数据失败:', error)
        return {}
      }
    },
    initMessageListener() {
      console.log('DevToolsPanel mounted, initializing listener')

      // 使用单例模式确保只有一个监听器
      if (typeof chrome !== 'undefined' && chrome.runtime) {
        // 如果已经有全局监听器，先移除
        if (window.cbgDevToolsListener) {
          chrome.runtime.onMessage.removeListener(window.cbgDevToolsListener)
        }

        // 创建全局监听器
        window.cbgDevToolsListener = (request, sender, sendResponse) => {
          console.log('DevToolsPanel received Chrome message:', request.action)
          this.handleChromeMessage(request, sender, sendResponse)
          sendResponse({ success: true })
        }

        // 注册监听器
        chrome.runtime.onMessage.addListener(window.cbgDevToolsListener)
        console.log('Chrome message listener registered for DevToolsPanel')
      }
    },

    removeMessageListener() {
      // 移除Chrome消息监听器
      if (typeof chrome !== 'undefined' && chrome.runtime && window.cbgDevToolsListener) {
        chrome.runtime.onMessage.removeListener(window.cbgDevToolsListener)
        delete window.cbgDevToolsListener
        console.log('Chrome message listener removed for DevToolsPanel')
      }
    },

    checkConnectionStatus() {
      // 检查Chrome扩展连接状态
      if (typeof chrome !== 'undefined' && chrome.runtime) {
        // 尝试发送ping消息检查连接
        chrome.runtime.sendMessage({ action: 'ping' }, (response) => {
          if (chrome.runtime.lastError) {
            console.log('Chrome extension connection check failed:', chrome.runtime.lastError)
            this.devtoolsConnected = false
            this.connectionStatus = '未连接'
          } else if (response && response.success) {
            console.log('Chrome extension connection check successful:', response)
            this.devtoolsConnected = true
            this.connectionStatus = '已连接'
          } else {
            console.log('Chrome extension connection check failed: invalid response')
            this.devtoolsConnected = false
            this.connectionStatus = '连接异常'
          }
        })
      } else {
        console.log('Chrome runtime not available')
        this.devtoolsConnected = false
        this.connectionStatus = 'Chrome环境不可用'
      }
    },

    handleChromeMessage(request, sender, sendResponse) {
      switch (request.action) {
        case 'updateRecommendData':
          this.recommendData = request.data || []

          // 按时间戳倒序排列，最新的在最上面
          this.recommendData.filter(item => parseListData(item.responseData)?.advance_search_type === 'overall_role_search').sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0))

          // 只处理新完成的请求，避免重复处理
          if (this.recommendData && this.recommendData.length > 0) {
            this.recommendData.forEach(item => {
              if (item.status === 'completed' &&
                item.responseData &&
                item.url &&
                item.requestId &&
                !this.processedRequests.has(item.requestId)) {

                // 标记为已处理
                this.processedRequests.add(item.requestId)
                console.log(`开始处理新请求: ${item.requestId}`)

                // 调用解析响应数据接口
                this.$api.spider.parseResponse({
                  url: item.url,
                  response_text: item.responseData
                }).then(res => {
                  console.log(`请求 ${item.requestId} 解析结果:`, res)
                  if (res.code === 200) {
                    console.log(`请求 ${item.requestId} 数据解析成功:`, res.data)
                  } else {
                    console.error(`请求 ${item.requestId} 数据解析失败:`, res.message)
                  }
                }).catch(error => {
                  console.error(`请求 ${item.requestId} 解析请求失败:`, error)
                  // 解析失败时移除标记，允许重试
                  this.processedRequests.delete(item.requestId)
                })
              }
            })
          }
          break

        case 'devtoolsConnected':
          this.devtoolsConnected = true
          this.connectionStatus = '已连接'
          this.$notify.success(request.message)
          break

        case 'showDebuggerWarning':
          this.devtoolsConnected = false
          this.connectionStatus = '连接冲突'
          this.$notify.warning(request.message)
          break

        case 'clearRecommendData':
          this.recommendData = []
          this.expandedItems = []
          this.processedRequests.clear()
          console.log('清空推荐数据和处理记录')
          break
      }
    },


    clearData() {
      this.recommendData = []
      this.expandedItems = []
      // 通知background script清空数据
      if (typeof chrome !== 'undefined' && chrome.runtime) {
        chrome.runtime.sendMessage({
          action: 'clearRecommendData'
        })
      }
    },

    toggleResponse(index) {
      const expandedIndex = this.expandedItems.indexOf(index)
      if (expandedIndex > -1) {
        this.expandedItems.splice(expandedIndex, 1)
      } else {
        this.expandedItems.push(index)
      }
    },

    formatTime(timestamp) {
      if (!timestamp) return ''
      const date = new Date(timestamp)
      return date.toLocaleTimeString()
    },

    checkIfInNewWindow() {
      // 检测是否在新窗口中打开
      try {

        // 方法1: 检查chrome.devtools API是否存在（最可靠的方法）
        if (typeof chrome !== 'undefined' && chrome.devtools && chrome.devtools.inspectedWindow) {
          this.isInNewWindow = false
          console.log('在Chrome扩展SidePanel中打开（通过API检测）')
          return
        }

        // 方法2: 检查URL模式 - 区分SidePanel和新窗口
        const currentUrl = window.location.href
        if (currentUrl.includes('chrome-extension://')) {
          // 检查是否是SidePanel页面
          if (currentUrl.includes('panel.html')) {
            // panel.html是SidePanel页面
            this.isInNewWindow = false
            console.log('在Chrome扩展SidePanel中打开（通过URL检测）')
            return
          } else if (currentUrl.includes('panel.html')) {
            // panel.html是新窗口页面
            this.isInNewWindow = true
            console.log('在新窗口中打开（通过URL检测）')
            return
          }
        }

        // 方法3: 检查页面标题
        if (document.title === '梦幻灵瞳') {
          // 需要进一步区分是SidePanel还是新窗口
          if (currentUrl.includes('panel.html')) {
            this.isInNewWindow = false
            console.log('在Chrome扩展SidePanel中打开（通过标题+URL检测）')
            return
          } else {
            this.isInNewWindow = true
            console.log('在新窗口中打开（通过标题检测）')
            return
          }
        }

        // 方法4: 检查是否在iframe中
        if (window.self !== window.top) {
          this.isInNewWindow = false
          console.log('在Chrome扩展SidePanel中打开（通过iframe检测）')
          return
        }

        // 方法5: 检查parent窗口
        if (window.parent === window) {
          // 顶级窗口，需要进一步判断
          if (currentUrl.includes('panel.html')) {
            this.isInNewWindow = false
            console.log('在Chrome扩展SidePanel中打开（通过parent+URL检测）')
          } else {
            this.isInNewWindow = true
            console.log('在新窗口中打开（通过parent检测）')
          }
        } else {
          this.isInNewWindow = false
          console.log('在Chrome扩展SidePanel中打开（通过parent检测）')
        }

      } catch (error) {
        console.error('检测窗口环境失败:', error)
        // 默认假设在新窗口中
        this.isInNewWindow = true
        console.log('检测失败，默认在新窗口中打开')
      }
    },

    async openInNewTab() {
      try {
        // 直接创建新标签页打开扩展页面
        const extensionUrl = chrome.runtime.getURL('panel.html')

        // 使用chrome.tabs.create在新标签页中打开
        await chrome.tabs.create({
          url: extensionUrl,
          active: true // 激活新标签页
        })

        this.$notify.success('已在新标签页中打开扩展面板')

      } catch (error) {
        console.error('打开新标签页失败:', error)

        // 如果chrome.tabs.create失败，尝试使用window.open
        try {
          const extensionUrl = chrome.runtime.getURL('panel.html')
          window.open(extensionUrl, '_blank')
          this.$notify.success('已在新窗口中打开扩展面板')
        } catch (fallbackError) {
          console.error('备用方法也失败:', fallbackError)
          this.$notify.error('打开新窗口失败: ' + error.message)
        }
      }
    },
  }
}
</script>

<style scoped>
.panel {
  box-sizing: border-box;
  padding: 16px;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  background: #f5f5f5;
  min-height: 100vh;
  background: url(~@/../public/assets/images/areabg.webp) repeat-y;
  width: 960px;
  margin: 0 auto;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 12px;
  border-bottom: 1px solid #e0e0e0;
}

.panel-header h3 {
  margin: 0;
  color: #333;
  font-size: 18px;
}

.connection-status {
  display: flex;
  align-items: center;
  gap: 10px;
}

.status-indicator {
  display: flex;
  align-items: center;
  gap: 6px;
}

.status-dot {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 4px;
  height: 4px;
  border-radius: 50%;
  display: inline-block;
  transition: all 0.3s ease;
}

.status-dot.connected {
  background-color: #52c41a;
  animation: pulse-green-strong 1.5s infinite;
}

.status-dot.disconnected {
  background-color: #faad14;
  animation: pulse-orange-strong 1s infinite;
}

/* 绿色强烈闪烁动画 */
@keyframes pulse-green-strong {
  0% {
    transform: translate(-50%, -50%) scale(1);
    box-shadow: 0 0 0 0 rgba(82, 196, 26, 0.7);
    opacity: 1;
  }
  50% {
    transform: translate(-50%, -50%) scale(1.2);
    box-shadow: 0 0 0 10px rgba(82, 196, 26, 0);
    opacity: 0.8;
  }
  100% {
    transform: translate(-50%, -50%) scale(1);
    box-shadow: 0 0 0 0 rgba(82, 196, 26, 0.7);
    opacity: 1;
  }
}

/* 橙色强烈闪烁动画 */
@keyframes pulse-orange-strong {
  0% {
    transform: translate(-50%, -50%) scale(1);
    box-shadow: 0 0 0 0 rgba(250, 173, 20, 0.7);
    opacity: 1;
  }
  25% {
    transform: translate(-50%, -50%) scale(1.3);
    box-shadow: 0 0 0 8px rgba(250, 173, 20, 0.4);
    opacity: 0.6;
  }
  50% {
    transform: translate(-50%, -50%) scale(1.1);
    box-shadow: 0 0 0 15px rgba(250, 173, 20, 0);
    opacity: 0.8;
  }
  75% {
    transform: translate(-50%, -50%) scale(1.2);
    box-shadow: 0 0 0 5px rgba(250, 173, 20, 0.2);
    opacity: 0.7;
  }
  100% {
    transform: translate(-50%, -50%) scale(1);
    box-shadow: 0 0 0 0 rgba(250, 173, 20, 0.7);
    opacity: 1;
  }
}

.status-text {
  font-size: 12px;
  color: #666;
  font-weight: 500;
}

.mode-indicator {
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 3px;
  font-weight: bold;
  margin-left: 8px;
}

.mode-indicator.sidepanel {
  background-color: #1890ff;
  color: white;
}

.mode-indicator.new-window {
  background-color: #52c41a;
  color: white;
}

.new-window-tip {
  margin-bottom: 16px;
  border-radius: 6px;
}

.new-window-tip p {
  margin: 4px 0;
  font-size: 12px;
  line-height: 1.4;
}

.sidebar-tip {
  margin-bottom: 16px;
  border-radius: 6px;
}

.sidebar-tip p {
  margin: 4px 0;
  font-size: 12px;
  line-height: 1.4;
}

.data-section h4 {
  margin: 0 0 12px 0;
  color: #666;
  font-size: 14px;
}

.empty-state {
  text-align: center;
  padding: 40px 20px;
  color: #999;
  background: white;
  border-radius: 4px;
  border: 1px dashed #ddd;
}

.request-list {
  background: white;
  border-radius: 4px;
  border: 1px solid #e0e0e0;
  overflow: hidden;
}

.request-item {
  border-bottom: 1px solid #f0f0f0;
  padding: 12px 16px;
  transition: background-color 0.2s;
}

.request-item:last-child {
  border-bottom: none;
}

.request-item:hover {
  background-color: #fafafa;
}

.request-item.completed {
  background-color: #f0f9ff;
  border-left: 3px solid #1890ff;
}

.request-info {
  margin-bottom: 8px;
}

.request-url {
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 12px;
  color: #333;
  word-break: break-all;
  margin-bottom: 4px;
}

.request-meta {
  display: flex;
  gap: 12px;
  font-size: 11px;
}

.method {
  background: #1890ff;
  color: white;
  padding: 2px 6px;
  border-radius: 2px;
  font-weight: bold;
}

.status {
  padding: 2px 6px;
  border-radius: 2px;
  font-weight: bold;
}

.status.pending {
  background: #faad14;
  color: white;
}

.status.completed {
  background: #52c41a;
  color: white;
}

.timestamp {
  color: #999;
}

.response-data {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid #f0f0f0;
}

.response-content {
  margin-top: 8px;
  background: #f8f8f8;
  border-radius: 4px;
  padding: 8px;
  max-height: 300px;
  overflow-y: auto;
}

.response-content pre {
  margin: 0;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 11px;
  line-height: 1.4;
  color: #333;
  white-space: pre-wrap;
  word-break: break-word;
}

.role-card /deep/.el-card__body {
  padding: 8px;
}

/* 空号卡片置灰样式 */
.role-card.empty-role {
  opacity: 0.6;
  filter: grayscale(0.8);
  background-color: #f5f5f5;
  border: 1px solid #d9d9d9;
  transition: all 0.3s ease;
}

.role-card.empty-role:hover {
  opacity: 0.8;
  filter: grayscale(0.6);
}

.role-card.empty-role /deep/.el-card__body {
  background-color: #fafafa;
}

/* 空号卡片内的元素也置灰 */
.role-card.empty-role .el-tag {
  opacity: 0.7;
}

.role-card.empty-role .el-link {
  opacity: 0.7;
}

.role-card.empty-role span {
  opacity: 0.7;
}
</style>
